// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: driver.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"ride-hail/pkg/uuid"
)

const createCoordinateForDriver = `-- name: CreateCoordinateForDriver :one
INSERT INTO coordinates (
  entity_id, entity_type, address,
  latitude, longitude, is_current
) VALUES ($1, 'driver', $2, $3, $4, true)
RETURNING id, created_at, updated_at, entity_id, entity_type, address, latitude, longitude, fare_amount, distance_km, duration_minutes, is_current
`

type CreateCoordinateForDriverParams struct {
	EntityID  uuid.UUID
	Address   string
	Latitude  pgtype.Numeric
	Longitude pgtype.Numeric
}

func (q *Queries) CreateCoordinateForDriver(ctx context.Context, arg CreateCoordinateForDriverParams) (Coordinate, error) {
	row := q.db.QueryRow(ctx, createCoordinateForDriver,
		arg.EntityID,
		arg.Address,
		arg.Latitude,
		arg.Longitude,
	)
	var i Coordinate
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EntityID,
		&i.EntityType,
		&i.Address,
		&i.Latitude,
		&i.Longitude,
		&i.FareAmount,
		&i.DistanceKm,
		&i.DurationMinutes,
		&i.IsCurrent,
	)
	return i, err
}

const createDriverSession = `-- name: CreateDriverSession :one
INSERT INTO driver_sessions (driver_id, started_at)
VALUES ($1, NOW())
RETURNING id, driver_id, started_at, ended_at, total_rides, total_earnings
`

func (q *Queries) CreateDriverSession(ctx context.Context, driverID uuid.UUID) (DriverSession, error) {
	row := q.db.QueryRow(ctx, createDriverSession, driverID)
	var i DriverSession
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalRides,
		&i.TotalEarnings,
	)
	return i, err
}

const createLocationHistory = `-- name: CreateLocationHistory :exec
INSERT INTO location_history (
  driver_id, latitude, longitude,
  accuracy_meters, speed_kmh, heading_degrees,
  ride_id, recorded_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
`

type CreateLocationHistoryParams struct {
	DriverID       uuid.UUID
	Latitude       pgtype.Numeric
	Longitude      pgtype.Numeric
	AccuracyMeters pgtype.Numeric
	SpeedKmh       pgtype.Numeric
	HeadingDegrees pgtype.Numeric
	RideID         uuid.UUID
}

func (q *Queries) CreateLocationHistory(ctx context.Context, arg CreateLocationHistoryParams) error {
	_, err := q.db.Exec(ctx, createLocationHistory,
		arg.DriverID,
		arg.Latitude,
		arg.Longitude,
		arg.AccuracyMeters,
		arg.SpeedKmh,
		arg.HeadingDegrees,
		arg.RideID,
	)
	return err
}

const endDriverSession = `-- name: EndDriverSession :one
UPDATE driver_sessions
SET ended_at = NOW(), total_rides = $2, total_earnings = $3
WHERE id = $1
RETURNING id, driver_id, started_at, ended_at, total_rides, total_earnings
`

type EndDriverSessionParams struct {
	ID            uuid.UUID
	TotalRides    pgtype.Int4
	TotalEarnings pgtype.Numeric
}

func (q *Queries) EndDriverSession(ctx context.Context, arg EndDriverSessionParams) (DriverSession, error) {
	row := q.db.QueryRow(ctx, endDriverSession, arg.ID, arg.TotalRides, arg.TotalEarnings)
	var i DriverSession
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalRides,
		&i.TotalEarnings,
	)
	return i, err
}

const findNearbyDrivers = `-- name: FindNearbyDrivers :many
SELECT d.id, d.vehicle_type, d.rating, d.status, u.email,
       d.vehicle_attrs,
       c.latitude, c.longitude,
       ST_Distance(
         ST_MakePoint(c.longitude, c.latitude)::geography,
         ST_MakePoint($1, $2)::geography
       ) / 1000 as distance_km
FROM drivers d
JOIN users u ON d.id = u.id
JOIN coordinates c ON c.entity_id = d.id
  AND c.entity_type = 'driver'
  AND c.is_current = true
WHERE d.status = 'AVAILABLE'
  AND d.vehicle_type = $3
  AND d.is_verified = true
  AND ST_DWithin(
    ST_MakePoint(c.longitude, c.latitude)::geography,
    ST_MakePoint($1, $2)::geography,
    $4 * 1000
  )
ORDER BY distance_km, d.rating DESC
LIMIT $5
`

type FindNearbyDriversParams struct {
	StMakepoint   interface{}
	StMakepoint_2 interface{}
	VehicleType   *string
	Column4       interface{}
	Limit         int
}

type FindNearbyDriversRow struct {
	ID           uuid.UUID
	VehicleType  *string
	Rating       pgtype.Numeric
	Status       string
	Email        string
	VehicleAttrs any
	Latitude     pgtype.Numeric
	Longitude    pgtype.Numeric
	DistanceKm   int32
}

func (q *Queries) FindNearbyDrivers(ctx context.Context, arg FindNearbyDriversParams) ([]FindNearbyDriversRow, error) {
	rows, err := q.db.Query(ctx, findNearbyDrivers,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.VehicleType,
		arg.Column4,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindNearbyDriversRow
	for rows.Next() {
		var i FindNearbyDriversRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleType,
			&i.Rating,
			&i.Status,
			&i.Email,
			&i.VehicleAttrs,
			&i.Latitude,
			&i.Longitude,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentDriverSession = `-- name: GetCurrentDriverSession :one
SELECT id, driver_id, started_at, ended_at, total_rides, total_earnings FROM driver_sessions
WHERE driver_id = $1 AND ended_at IS NULL
ORDER BY started_at DESC
LIMIT 1
`

func (q *Queries) GetCurrentDriverSession(ctx context.Context, driverID uuid.UUID) (DriverSession, error) {
	row := q.db.QueryRow(ctx, getCurrentDriverSession, driverID)
	var i DriverSession
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalRides,
		&i.TotalEarnings,
	)
	return i, err
}

const getDriverCurrentLocation = `-- name: GetDriverCurrentLocation :one
SELECT id, created_at, updated_at, entity_id, entity_type, address, latitude, longitude, fare_amount, distance_km, duration_minutes, is_current FROM coordinates
WHERE entity_id = $1 AND entity_type = 'driver' AND is_current = true
LIMIT 1
`

func (q *Queries) GetDriverCurrentLocation(ctx context.Context, entityID uuid.UUID) (Coordinate, error) {
	row := q.db.QueryRow(ctx, getDriverCurrentLocation, entityID)
	var i Coordinate
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EntityID,
		&i.EntityType,
		&i.Address,
		&i.Latitude,
		&i.Longitude,
		&i.FareAmount,
		&i.DistanceKm,
		&i.DurationMinutes,
		&i.IsCurrent,
	)
	return i, err
}

const markDriverCoordinatesAsOld = `-- name: MarkDriverCoordinatesAsOld :exec
UPDATE coordinates
SET is_current = false, updated_at = NOW()
WHERE entity_id = $1 AND entity_type = 'driver' AND is_current = true
`

func (q *Queries) MarkDriverCoordinatesAsOld(ctx context.Context, entityID uuid.UUID) error {
	_, err := q.db.Exec(ctx, markDriverCoordinatesAsOld, entityID)
	return err
}

const updateDriverRide = `-- name: UpdateDriverRide :exec
UPDATE drivers
SET updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateDriverRide(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateDriverRide, id)
	return err
}

const updateDriverStats = `-- name: UpdateDriverStats :exec
UPDATE drivers
SET total_rides = total_rides + 1,
    total_earnings = total_earnings + $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateDriverStatsParams struct {
	ID            uuid.UUID
	TotalEarnings pgtype.Numeric
}

func (q *Queries) UpdateDriverStats(ctx context.Context, arg UpdateDriverStatsParams) error {
	_, err := q.db.Exec(ctx, updateDriverStats, arg.ID, arg.TotalEarnings)
	return err
}

const updateDriverStatus = `-- name: UpdateDriverStatus :exec
UPDATE drivers
SET status = $1, updated_at = NOW()
WHERE id = $2
`

type UpdateDriverStatusParams struct {
	Status string
	ID     uuid.UUID
}

func (q *Queries) UpdateDriverStatus(ctx context.Context, arg UpdateDriverStatusParams) error {
	_, err := q.db.Exec(ctx, updateDriverStatus, arg.Status, arg.ID)
	return err
}

const updateRideCompleted = `-- name: UpdateRideCompleted :one
UPDATE rides
SET status = 'COMPLETED',
    completed_at = NOW(),
    final_fare = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, created_at, updated_at, ride_number, passenger_id, driver_id, vehicle_type, status, priority, requested_at, matched_at, arrived_at, started_at, completed_at, cancelled_at, cancellation_reason, estimated_fare, final_fare, pickup_coordinate_id, destination_coordinate_id
`

type UpdateRideCompletedParams struct {
	ID        uuid.UUID
	FinalFare pgtype.Numeric
}

func (q *Queries) UpdateRideCompleted(ctx context.Context, arg UpdateRideCompletedParams) (Ride, error) {
	row := q.db.QueryRow(ctx, updateRideCompleted, arg.ID, arg.FinalFare)
	var i Ride
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RideNumber,
		&i.PassengerID,
		&i.DriverID,
		&i.VehicleType,
		&i.Status,
		&i.Priority,
		&i.RequestedAt,
		&i.MatchedAt,
		&i.ArrivedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.EstimatedFare,
		&i.FinalFare,
		&i.PickupCoordinateID,
		&i.DestinationCoordinateID,
	)
	return i, err
}

const updateRideMatched = `-- name: UpdateRideMatched :exec
UPDATE rides
SET status = 'MATCHED',
    driver_id = $1,
    matched_at = NOW(),
    updated_at = NOW()
WHERE id = $2
`

type UpdateRideMatchedParams struct {
	DriverID uuid.UUID
	ID       uuid.UUID
}

func (q *Queries) UpdateRideMatched(ctx context.Context, arg UpdateRideMatchedParams) error {
	_, err := q.db.Exec(ctx, updateRideMatched, arg.DriverID, arg.ID)
	return err
}

const updateRideStarted = `-- name: UpdateRideStarted :exec
UPDATE rides
SET status = 'IN_PROGRESS',
    started_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateRideStarted(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateRideStarted, id)
	return err
}

const updateRideStatus = `-- name: UpdateRideStatus :exec
UPDATE rides
SET status = $1, updated_at = NOW()
WHERE id = $2
`

type UpdateRideStatusParams struct {
	Status *string
	ID     uuid.UUID
}

func (q *Queries) UpdateRideStatus(ctx context.Context, arg UpdateRideStatusParams) error {
	_, err := q.db.Exec(ctx, updateRideStatus, arg.Status, arg.ID)
	return err
}

const updateSessionStats = `-- name: UpdateSessionStats :exec
UPDATE driver_sessions
SET total_rides = total_rides + 1,
    total_earnings = total_earnings + $2
WHERE id = $1
`

type UpdateSessionStatsParams struct {
	ID            uuid.UUID
	TotalEarnings pgtype.Numeric
}

func (q *Queries) UpdateSessionStats(ctx context.Context, arg UpdateSessionStatsParams) error {
	_, err := q.db.Exec(ctx, updateSessionStats, arg.ID, arg.TotalEarnings)
	return err
}
