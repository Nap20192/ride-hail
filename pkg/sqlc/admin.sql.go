// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: admin.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"ride-hail/pkg/uuid"
)

const getActiveRidesCount = `-- name: GetActiveRidesCount :one

SELECT COUNT(*) as count
FROM rides 
WHERE status IN ('MATCHED', 'EN_ROUTE', 'ARRIVED', 'IN_PROGRESS')
`

// Admin Service Queries
func (q *Queries) GetActiveRidesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getActiveRidesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getActiveRidesPaginated = `-- name: GetActiveRidesPaginated :many
SELECT 
  r.id,
  r.ride_number,
  r.status,
  r.passenger_id,
  r.driver_id,
  r.started_at,
  r.requested_at,
  p.email as passenger_email,
  d.email as driver_email,
  r.estimated_fare,
  pickup_coord.address as pickup_address,
  dest_coord.address as destination_address,
  pickup_coord.latitude as pickup_latitude,
  pickup_coord.longitude as pickup_longitude,
  dest_coord.latitude as destination_latitude,
  dest_coord.longitude as destination_longitude
FROM rides r
LEFT JOIN users p ON r.passenger_id = p.id
LEFT JOIN users d ON r.driver_id = d.id
LEFT JOIN coordinates pickup_coord ON r.pickup_coordinate_id = pickup_coord.id
LEFT JOIN coordinates dest_coord ON r.destination_coordinate_id = dest_coord.id
WHERE r.status IN ('MATCHED', 'EN_ROUTE', 'ARRIVED', 'IN_PROGRESS')
ORDER BY r.requested_at DESC
LIMIT $1 OFFSET $2
`

type GetActiveRidesPaginatedParams struct {
	Limit  int
	Offset int
}

type GetActiveRidesPaginatedRow struct {
	ID                   uuid.UUID
	RideNumber           string
	Status               *string
	PassengerID          uuid.UUID
	DriverID             uuid.UUID
	StartedAt            *time.Time
	RequestedAt          *time.Time
	PassengerEmail       pgtype.Text
	DriverEmail          pgtype.Text
	EstimatedFare        pgtype.Numeric
	PickupAddress        *string
	DestinationAddress   *string
	PickupLatitude       pgtype.Numeric
	PickupLongitude      pgtype.Numeric
	DestinationLatitude  pgtype.Numeric
	DestinationLongitude pgtype.Numeric
}

func (q *Queries) GetActiveRidesPaginated(ctx context.Context, arg GetActiveRidesPaginatedParams) ([]GetActiveRidesPaginatedRow, error) {
	rows, err := q.db.Query(ctx, getActiveRidesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveRidesPaginatedRow
	for rows.Next() {
		var i GetActiveRidesPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.RideNumber,
			&i.Status,
			&i.PassengerID,
			&i.DriverID,
			&i.StartedAt,
			&i.RequestedAt,
			&i.PassengerEmail,
			&i.DriverEmail,
			&i.EstimatedFare,
			&i.PickupAddress,
			&i.DestinationAddress,
			&i.PickupLatitude,
			&i.PickupLongitude,
			&i.DestinationLatitude,
			&i.DestinationLongitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveRidesTotalCount = `-- name: GetActiveRidesTotalCount :one
SELECT COUNT(*) as count
FROM rides
WHERE status IN ('MATCHED', 'EN_ROUTE', 'ARRIVED', 'IN_PROGRESS')
`

func (q *Queries) GetActiveRidesTotalCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getActiveRidesTotalCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAvailableDriversCount = `-- name: GetAvailableDriversCount :one
SELECT COUNT(*) as count
FROM users 
WHERE role = 'DRIVER' 
  AND attrs->>'driver_status' = 'AVAILABLE'
`

func (q *Queries) GetAvailableDriversCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getAvailableDriversCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAverageRideDuration = `-- name: GetAverageRideDuration :one
SELECT COALESCE(AVG(EXTRACT(EPOCH FROM (completed_at - started_at)) / 60), 0) as avg_minutes
FROM rides
WHERE completed_at IS NOT NULL
  AND started_at IS NOT NULL
  AND DATE(completed_at) = CURRENT_DATE
`

func (q *Queries) GetAverageRideDuration(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, getAverageRideDuration)
	var avg_minutes interface{}
	err := row.Scan(&avg_minutes)
	return avg_minutes, err
}

const getAverageWaitTime = `-- name: GetAverageWaitTime :one
SELECT COALESCE(AVG(EXTRACT(EPOCH FROM (matched_at - requested_at)) / 60), 0) as avg_minutes
FROM rides
WHERE matched_at IS NOT NULL
  AND DATE(requested_at) = CURRENT_DATE
`

func (q *Queries) GetAverageWaitTime(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, getAverageWaitTime)
	var avg_minutes interface{}
	err := row.Scan(&avg_minutes)
	return avg_minutes, err
}

const getBusyDriversCount = `-- name: GetBusyDriversCount :one
SELECT COUNT(*) as count
FROM users 
WHERE role = 'DRIVER' 
  AND attrs->>'driver_status' = 'BUSY'
`

func (q *Queries) GetBusyDriversCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getBusyDriversCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCancellationRate = `-- name: GetCancellationRate :one
SELECT 
  CASE 
    WHEN COUNT(*) = 0 THEN 0
    ELSE (COUNT(*) FILTER (WHERE status = 'CANCELLED')::float / COUNT(*)::float) * 100
  END as rate
FROM rides
WHERE DATE(requested_at) = CURRENT_DATE
`

func (q *Queries) GetCancellationRate(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, getCancellationRate)
	var rate interface{}
	err := row.Scan(&rate)
	return rate, err
}

const getDriverDistributionByVehicleType = `-- name: GetDriverDistributionByVehicleType :many
SELECT 
  COALESCE(attrs->>'vehicle_type', 'UNKNOWN') as vehicle_type,
  COUNT(*) as count
FROM users 
WHERE role = 'DRIVER' 
  AND attrs->>'driver_status' != 'OFFLINE'
GROUP BY attrs->>'vehicle_type'
`

type GetDriverDistributionByVehicleTypeRow struct {
	VehicleType interface{}
	Count       int64
}

func (q *Queries) GetDriverDistributionByVehicleType(ctx context.Context) ([]GetDriverDistributionByVehicleTypeRow, error) {
	rows, err := q.db.Query(ctx, getDriverDistributionByVehicleType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDriverDistributionByVehicleTypeRow
	for rows.Next() {
		var i GetDriverDistributionByVehicleTypeRow
		if err := rows.Scan(&i.VehicleType, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodayRevenue = `-- name: GetTodayRevenue :one
SELECT COALESCE(SUM(final_fare), 0) as total
FROM rides 
WHERE DATE(completed_at) = CURRENT_DATE 
  AND status = 'COMPLETED'
`

func (q *Queries) GetTodayRevenue(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, getTodayRevenue)
	var total interface{}
	err := row.Scan(&total)
	return total, err
}

const getTodayRidesCount = `-- name: GetTodayRidesCount :one
SELECT COUNT(*) as count
FROM rides 
WHERE DATE(requested_at) = CURRENT_DATE
`

func (q *Queries) GetTodayRidesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTodayRidesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}
